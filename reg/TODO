xlattice_go/reg/TODO

2013-10-12
    * eph_server_test.go step 4, 5                                      * DONE
    * need clear decision: does UserClient get clusterName?
    * use BloomSHA3 to handle registry ID map?  about 300 SLOC
        in Java

2013-10-11
    * in mock_server_test.go				                            * DONE
        - REPLACE NewMockClient BY NewUserClient, about line 53			* DONE
        - REPLACE MockClient BY UserClient, about line 74		        * DONE
    * msg_handlers doClientMsg about line 70 sets all generated
        IDs to 32 bytes (SHA3)
    * AdminClient accepts epCount but not part of protocol
        - add to p.proto
        - server must make this part of registry data structure
        - UserClients get epCount in JoinReply
    * doClientMsg assigns an ID if nil but just uses the SHA3 
        of ckPriv and skPriv; need to add some randomness!
    * server must guarantee uniqueness of all IDs, including 
        - unique clientID (both user and admin)
        - unique clusterID
    * so registry must have a map of all IDs used
    * add cluster attrs (already present in RegCluster struct as Attrs)
        - to protocol                                                   * DONE
        - to const in reg_cluster.go                                    * DONE
        - to client CreateMsg
        - to server CreateReply
    * IMPLEMENT USER CLIENT                                             * DONE

2013-10-10
    * msg_handlers.go doClientMsg: change to either 
        - accept ID, which must be known, plus digsig
        - or to accept token without ID plus digsig
            * in this case it generates a new and unique ID
        - old tests must continue to run at least until new
            code is stable

    * reorganize client code to give us a base class ClientNode
        with subclasses UserClient and AdminClient
        - rename the old files and types to reduce confusion
            * client.go becomes old_client.go (so OldClient)            * DONE
            * mock_client.go reappears (was briefly client_node.go)     * DONE
            * client_run.go becomes old_client_run.go                   * DONE
            * mock_server_test.go becomes old_server_test.gon           * DONE
        - copy old_client.go as client_node.go
            - this is the base class
            - either creates keys on the fly                            * DONE
            - or reads config from LFS
            - gets unique nodeID from the server
                * CHANGE Client/ClientOK to expect either
                    - token without name but with digSig OR
                    - clientID plus digSig
            - node is created after keys are created and ID is known
            - Node is part of ClientNode struct
    * Run() is defined differently for user and admin clients
    * user_client.go 
    * admin_client.go                                                   * DONE
    * new eph_server_test.go is old code with a few changes
        - incorporates an admin client

2013-10-09
    PROTOCOL
    * ClientMsg is EITHER token without clientID OR clientID;
        in either case plus a digital signature

2013-10-03
    * verify that mock_server_test considers it an error when
        not all members are returned 

2013-10-02
    CLIENT, MOCK_CLIENT
    * mock_client renamed client_node.go                                * DONE
    * MockClient becomes ClientNode                                     * DONE
    * client.go reorganized a bit so that it either loads or
        creates a ClientNode
    
    * change protocol so that nodeID is assigned by server (to
        avoid Douceur's Sybil Attack)
        - so first variant of Client message has token + digSig
            * without clientID in token
                - any client ID is ignored and discarded
                - which will cause digSig to be wrong
        - second version of Client message has only clientID + digSig
        - either attaches client's full token to the connection
            * this includes nodeID
    * move Node into Client struct 
    * code up the usual serialization/deserialization 
        * ParseClient
        * Client.String()
        * Client.Strings()
        * Client.Run()
    * when a Client is run, 
        - if it has a configuration in its lfs, it loads = does a 
            ParseClient on its configuration file; this returns
            a Client with a *xn.Node field
        - otherwise it starts talking to the server (does a 
            Hello/Reply to get a session key) and then sends a
            Client message without a nodeID; the nodeID returned
            is used to build its *xn.Node
    * if testing (-T option), default lfs is ./tmp/ID/lfs, where
        ID is the hex version of the server-assigned ID
    * otherwise default lfs is ./lfs
        - so there is one obvious configuration file in a subdirectory
            of the current directory
    
    SERVER, CLIENT/SERVER MESSAGING
    * it must be possible for a Client to create a Cluster (by name)
        and set its size without joining it
        - ah: it must be possible for a Client to create a Cluster
            without a name and get its assigned name and ID back
    * equally it must be possible for a client to join a cluster 
        using its name and get its ID back
        - but if its full the client gets a ClusterFull error msg

    * rename Get msg to GetCluster, Members to ClusterMembers           * DONE
    * code up RegNode serialization in reg/reg_node.go:				    * DONE
        - ParseRegNode()							                    * DONE
        - String()						                            	* DONE
        - Strings()							                            * DONE

    * code up Registry serialization in reg/registry.go:
        - ParseRegistry()
        - String()
        - Strings()

    * code up RegServer bits in reg/server.go:
        - Run()                                                         * DONE
        - ParseRegServer()
        - String()
        - Strings()

    * any errors found by InHandler should be logged

2013-10-01
    * InHandler.Run() needs range check on op or tag about line 169     * DONE
    * need locking for reg_cluster Members 
        - checking whether client is cluster member by name (read lock) * DONE
        - adding member to cluster by name (write lock)                 * DONE
        - checking whether client is cluster member by ID (read lock)
        - adding member to cluster by ID (write lock)                   * DONE
    * registry RegMembersByID should be dropped or used; if used
        - when members added to clusters
            * must read lock reg and check reg.RegMembersByID
            * must write lock when adding
        - but need to decide whether this is useful
            * and whether the intention is to prevent clients from
                belonging to more than one cluster (why??)
    * move relevant bits of MockServer into reg/server.go               * DONE
        - implement reg.Server.NewServer(...)                           * DONE
        - and reg.Server.Run(...)                                       * DONE
    * when this is running, drop into ../cmd/xlReg/xlReg

2013-09-30
    * xlReg loads from/saves to lfs (see 09-16 TODO)
    * xlReg 0.2.0 must have lfs, logging, load/save
    * deploy xlReg 0.2.0 on salinas:55555
2013-09-29
    * improve RegCluster.AddMember handling of dupe names
2013-09-24
    * packets.go readData should handle partial reads, looping on count 
        until all bytes have been received
    * packets.go writeData should handle partial writes, looping on count 
        until all bytes have gone
2013-09-20
    * several tests could obviously benefit from parallelizing: 
        they run one CPU at 100% while the others are more or less idle
        - look at cluster_member_test
        - also reg_cluster_test 
2013-09-16
    * regNode serialization follows practice in ../node: we first
        serialize BaseNode, then rest of Node, then fields of 
        RegNode
        - need Strings(), String(), Parse()
2013-09-13
    * URGENT FIX: ClientMsg does NOT include digsig, so server cannot 
        verify that the client knows skPriv
    * longer term xlReg needs to be distributed, using Paxos for
        consensus
2013-09-12
    * build and thoroughly test ../cmd/xlReg
    * this stays on main branch
    * deploy on test:44444 as service

    * on regBeta branch figure out how to persist the registry in 
        such a way this it easily loads itself from disk after a 
        crash or reboot
    * when this is stable, merge back into main branch
        - and deploy on test:44444
    * document
